Hello World App

## Hello World App

Ok donc on est pêt pour développer notre première application qui risque d'être si époustouflante que nous n'allons pas nous arrêter en si bon chemin !!! :-)

D'abord, créons le répertoire qui contiendra les sources de toutes nos applications

    $mkdir -p /opt/toolkit/source/

Pour l'instant, ce répertoire est vide, nous allons y créer le répertoire pour notre première application qu'on nommera ***syno-library***.

    $mkdir -p /opt/toolkit/source/syno-library

Une fois terminé, nous devrions avoir les répertoires suivants: 

    + syno-library
        + package
            + ui
                + images
                + texts
                    + enu
                    + fre
        + scripts
        + SynoBuildConf

Le répertoire "scripts" contient tous les scripts shell exécutés lors le déploiement initial, la mise à jour, etc du package. Le répertoire "SynoBuildConf" contient les informations nécessaires à la génération du package lui-même. Pour finir, le répertoire "package" contient tous les fichiers à déployer.

Nous aurons besoin d'un logo, personnellement j'en ai déjà choisi un. Il nous le faut dans plusieurs tailles: 16px, 24px, 32px, 36px, 48px, 64px, 72px, 128px, 144px, 256px. Je ne suis pas sûr que toutes ces tailles soient vraiment nécessaires, .... mais bon pour éviter tout souci.

J'ai choisi cette icône: http://www.iconarchive.com/show/animal-icons-by-martin-berube/wolf-icon.html

J'ai créé un nouveau répertoire et j'y ai enregistré toutes ces images. Elles seront nécessaires, certaines du moins, plus tard lorsque nous développerons le "front" de notre application.

    $mkdir -p /opt/toolkit/source/syno-library/package/ui/images

    $cd /opt/toolkit/source/syno-library/package/ui/images

    $wget http://icons.iconarchive.com/icons/martin-berube/animal/256/wolf-icon.png --output-document syno-library_256.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/256/wolf-icon.png --output-document syno-library_144.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/128/wolf-icon.png --output-document syno-library_128.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/128/wolf-icon.png --output-document syno-library_72.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/64/wolf-icon.png --output-document syno-library_64.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/48/wolf-icon.png --output-document syno-library_48.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/48/wolf-icon.png --output-document syno-library_36.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/32/wolf-icon.png --output-document syno-library_32.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/24/wolf-icon.png --output-document syno-library_24.png
    $wget http://icons.iconarchive.com/icons/martin-berube/animal/16/wolf-icon.png --output-document syno-library_16.png

Nous avons également besoin de cette icône dans deux tailles différentes pour l'afficher au sein du "Package Manager", nous copions donc celle qui nous intéresse et les renommons 

    $cp syno-library_256.png ../../../PACKAGE_ICON_256.PNG
    $cp syno-library_72.png ../../../PACKAGE_ICON.PNG    

Si vous avez fait attention, vous aurez remarqué que certaines images n'existent pas dans les tailles souhaitées, donc je les ai téléchargées dans des tailles plus grandes et grâce à Gimp je les redimensionnerai. Vous aurez également remarqué que j'ai renommé les images pour respecter le pattern spécifique: {PACKAGE_NAME}_{SIZE}.{ext}

Notre semblant d'application "Hello World" ne requière aucun shell script pour le moment, mais avec DSM v6 ils doivent être présent donc nous allons les créer. Pour le moment il ne feront rien, mais plus tard nous les exploiterons et donc nous les expliquerons.

    $cd /opt/toolkit/source/syno-library/
    $mkdir -p /opt/toolkit/source/syno-library/scripts

    $echo -e '#!/bin/sh\nexit 0' > ./scripts/postinst
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/postuninst
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/postupgrade
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/preinst
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/preuninst
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/preupgrade
    $echo -e '#!/bin/sh\nexit 0' > ./scripts/start-stop-status

Pour fonctionner, ces scripts doivent bien sûr être exécutables. DSM v5 ne se plaint pas, mais rien ne se passe et ça peut prendre du temps avant de comprendre d'où vient le problème, croyez en mon expérience :-(.

    $chmod +x ./scripts/*

Le dernier répertoire à créer est "SynoBuildConf". Comme déjà expliqué, ce répertoire contient 3 fichiers utilisés pour générer le package:

    $cd /opt/toolkit/source/syno-library/
    $mkdir -p /opt/toolkit/source/syno-library/SynoBuildConf

Le premier fichier est nommé "build", c'est un script shell qui est appelé pour builder/compiler le projet (code C par exemple). Pour le moment ce script peut être vide.

    $echo 'exit 0' > ./SynoBuildConf/build

Le second fichier est nommé "depends", il définit la liste des dépendences dont aura besoin PkgCreate pour générer notre package. Pour le moment, nous n'avons aucune dépendence, mais il ne peut pas être vide car nous devons définir la plateforme cible.

    $cat << __EOF__ > ./SynoBuildConf/depends
    [BuildDependent]
    # each line here is a dependent project
    
    [ReferenceOnly]
    # each line here is a project for reference only but no need to be built
    
    [default]
    all="5.2"   # toolkit environment version of specific platform. (all platform use 5.2 toolkit environment)

Et pour finir, nous avons le fichier nommé "install", ce fichier est un script shell qui assemble tous les éléments (fichiers) dans le package.

Notre package doit contenir:

    Les 2 images, celles choisies précédemment et nommées PACKAGE_ICON....
    Le répertoire "scripts" avec les fichiers scripts précédemment créés
    Les librairies, les fichiers GUI (pour plus tard), etc (tous les  fichiers qui doivent être copiés sur le NAS) qui seront eux-mêmes réunis dans un fichier archive nommé package.tgz
    Et finalement un fichier nommé "INFO" qui descrit notre package (nom, version, etc.)

Pour créer ce fichier nous devons définir les propriétés suivantes (bien sûr nous sommes libres de choisir celle que nous voulons) :

    Le nom du package --> syno-library
    Le numéro de version --> 0.0.0001
    L'architecture cible --> bromolow (voir plus haut comment la définir)
    Une description --> syno-library
    Un titre --> syno-library
    Qui le maintient --> Synology community

A terme, l'idée est de pouvoir utiliser des fichiers de traduction pour les différentes langues. Le titre et la description choisie s'y rouveront. Nous devons donc déterminer où ces fichiers se trouveront. Généralement ce fichiers se trouvent dans le répertoire suivante: ***./source/syno-library/package/ui/texts***.
Le fichier de traduction sont globalement des fichiers de propriétés standards ***KEY=VALUE***, mais il existe également un regroupement en ***section***, ce qui permet d'utiliser la même clé plusieurs fois dans différentes sections. Nous placerons notre titre et notre description dans la section principale que nous nommerons ***app***

Pour l'anglais:

    $cd /opt/toolkit/source/syno-library/package/ui/texts
    $cat << __EOF__ > ./enu/strings
    [app]
    title = "syno-library"
    description = "syno-library"
    __EOF__

Pour le français:

    $cd /opt/toolkit/source/syno-library/package/ui/texts
    $cat << __EOF__ > ./fre/strings
    [app]
    title = "syno-library"
    description = "syno-library"
    __EOF__

Quelques informations supplémentaires sont nécessaires mais elles peuvent être automatiquement déterminées, donc nous sauterons sur l'occasion de ne rien faire :-)

    cat << __EOF__ > ./INFO.sh
    #!/bin/bash
    # Copyright (c) 2000-2016 Synology Inc. All rights reserved.
    
    source /pkgscripts/include/pkg_util.sh
    
    UISTRING_PATH="/source/syno-library/package/ui/texts"
    description_sec="app"
    description_key="description"
    displayname_sec="app"
    displayname_key="title"

    package="${PACKAGE_NAME}"
    version="${PACKAGE_VERSION}"
    maintainer="${PACKAGE_MAINTAINER}"
    arch="${NAS_ARCH}"
    
    [ "\$(caller)" != "0 NULL" ] && return 0
    pkg_dump_info
    __EOF__

Etfinalement comme à chaque fois, le script doit être exécutable:

    $chmod +x INFO.sh

Cette première partie était relativement simple, mais nous n'avons pas encore fini.

En effet, il reste le fichier "install" qui assemble tous les fichiers précédemment créés, et donc peut être le plus important

    $cd /opt/toolkit/source/syno-library/
    $cat << __EOF__ > ./SynoBuildConf/install
    #!/bin/bash
    # Copyright (C) 2000-2016 Synology Inc. All rights reserved.
    
    ### Use PKG_DIR as working directory.
    PKG_DIR=/tmp/_test_spk
    rm -rf \$PKG_DIR
    mkdir -p \$PKG_DIR
    
    ### get spk packing functions
    source /pkgscripts/include/pkg_util.sh
    
    create_package_tgz() {
        local fireware_version=
        local package_tgz_dir=/tmp/_package_tgz
    
        ### clear destination directory
        if [ -d \$package_tgz_dir ];
        then
          rm -r \$package_tgz_dir
        fi
    
        mkdir -p \$package_tgz_dir
    
        cp -R package/* \$package_tgz_dir
    
        ### create package.tgz \$1: source_dir \$2: dest_dir
        pkg_make_package \$package_tgz_dir "\${PKG_DIR}"
    }
    
    create_spk(){
        local conf_dir=\$PKG_DIR/conf
        local scripts_dir=\$PKG_DIR/scripts

        ### Copy Package Center scripts to PKG_DIR
        mkdir -p \$scripts_dir
        cp -av scripts/* \$scripts_dir
    
        ### Copy package icon
        cp -av PACKAGE_ICON*.PNG \$PKG_DIR
    
        ### Generate INFO file
        ./INFO.sh > INFO
        cp INFO \$PKG_DIR/INFO
    
        ### Create the final spk.
        # pkg_make_spk <source path> <dest path> <spk file name>
        # Please put the result spk into /image/packages
        # spk name functions: pkg_get_spk_name pkg_get_spk_unified_name pkg_get_spk_family_name
        mkdir -p /image/packages
        pkg_make_spk \${PKG_DIR} "/image/packages" ${PACKAGE_NAME}-${PACKAGE_VERSION}.spk
    }
    
    main() {
        create_package_tgz
        create_spk
    }
    
    main "\$@"
    __EOF__

Parfait, je n'ai perdu personne ?! Bon il ne nous reste plus qu'une chose à faire ... Générer notre package et pour cela une seule et dernière commande suffit:

    ./pkgscripts/PkgCreate.py -x0 --no-sign -c syno-library

Nous avons la possibilité de signer les packages que nous créons. Dans un premier temps j'ai choisi de ne pas le faire c'est pour ça que j'utilise l'option ***--no-sign***, mais si vous le souhaitez libre à vous de les signer. Il suffit de générer une clé à copier dans le répertoire /opt/toolkit/build_env/ds.bromolow-5.2/root/.gnupg/ (ceci est expliqué dans la documentation synology dont le lien est rappelé plus haut).

Comme dit précédemment, toutes ces étapes on été rassemlées dans un seul et même scipt shell. Vous pouvez y jetez un coup d'oeil, le modifier et l'utiliser comme bon vous semble mais je me dégage de toute responsabilité bien sûr. 
